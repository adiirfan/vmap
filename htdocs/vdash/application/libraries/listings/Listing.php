<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');

require_once(dirname(__FILE__) . '/../EB_Library.php');

/**
 * Listing
 * 
 * -------------------------------------
 * Dependencies
 * -------------------------------------
 * + Pagination (CI Library)
 * 
 * Please build the query using the default database
 * object: $this->_CI->db
 * 
 * The query build up should done in the init() function.
 * 
 * @author kflee
 * @version 2.0
 */
class Listing extends EB_Library {
	/**
	 * To allowed multiple column sorting.
	 * By default, this was set to FALSE.
	 * 
	 * @var boolean
	 */
	protected $_allowed_multiple_sort = false;
	
	/**
	 * The base URL to the listing page.
	 * If this was not set, the library will guest
	 * the URL automatically.
	 * 
	 * NOTE: This property has been deprecated as the library is
	 * smart enough to guess the current URL.
	 * 
	 * @deprecated
	 * @var string
	 */
	protected $_base_url = '';
	
	/**
	 * The column name and it's database
	 * field binding. The array key will
	 * be the column name. The array value
	 * will be the database field's name.
	 * The array value is optional as the
	 * value can be obtained from custom
	 * formatting function:
	 * protected function _format_columnname($index, $value, $row);
	 * 
	 * @var array
	 */
	protected $_columns = array();
	
	/**
	 * This will store the weight of each column. This
	 * will not store the exact pixel width, but rather
	 * the number of propotions. The array key will be
	 * the column key. The value will be the propotion
	 * value.
	 * 
	 * Eg: array(
	 *     'column1' => 1,
	 *     'column2' => 2,
	 *     'column3' => 5,
	 * )
	 * 
	 * If the total width is 1000px. So column 1 will take
	 * 125px, column 2 will be 250px and column 3 will take
	 * 625px.
	 * 
	 * If happened there are any column that did not defined
	 * in this width, they are automatically assigned as 1.
	 * Eg: column 4, the width will be 111.11px (after divded
	 * by 9 columns)
	 * 
	 * @var array
	 */
	protected $_column_weights = array();
	
	/**
	 * The data generated by the listing.
	 * Is a multidimension array. This data
	 * is generated in the _process() method.
	 * 
	 * @var array
	 */
	protected $_data = array();
	
	/**
	 * The list of filters applied to this listing.
	 * It is an associative array where the key is
	 * the filter ID which will be used in the URI
	 * segment or field name. The value will be the
	 * database field's name and it is optional.
	 * If database field's name was set, the library
	 * will use it to compare with the client's value.
	 * 
	 * The value can accept value token as below:
	 * $_filters['key'] = 'db_field LIKE %[value]%';
	 * $_filters['key'] = 'db_field <> [value]';
	 * $_filters['key'] = 'db_field >';
	 * $_filters['key'] = 'db_field'; // This will match using = equal sign
	 * 
	 * If none of the standard operator suite your
	 * needs, you can leave the array value empty:
	 * $_filters['key'] = '';
	 * 
	 * Then, use custom filter function to manipulate
	 * the database query. The function name is
	 * assosciated with the key.
	 * The first parameter is the database object. You
	 * can use it to customize the query. The second
	 * parameter is the value posted back by client.
	 * You can use it to apply to your query.
	 * protected function _filter_keyname($db, $value);
	 * 
	 * @var array
	 */
	protected $_filters = array();
	
	/**
	 * The column label for the table listing.
	 * The array key will be the column's ID
	 * while the value will be the label.
	 * 
	 * @var array
	 */
	protected $_labels = array();
	
	/**
	 * The SQL string for the last query.
	 * 
	 * @var string
	 */
	protected $_last_query = '';
	
	/**
	 * The layout script of the listing when
	 * render on HTML page.
	 * 
	 * @var string
	 */
	protected $_layout = 'default';
	
	/**
	 * The number of records per page.
	 * 
	 * @var int
	 */
	protected $_per_page = 0;
	
	/**
	 * This will set the number of link appear before and after
	 * the current selected page.
	 * 
	 * @var int
	 */
	protected $_num_links = 0;
	
	/**
	 * The list of sorts that applied to this listing.
	 * It is an associative array where the key is the
	 * sorting ID which will be used in the sort link
	 * and URI segment.
	 * The value of the array will be the database field
	 * that apply for the sorting. It can be empty so
	 * the library will call up a custom sorting function
	 * based on the key name:
	 * protected function _sort_keyname($db);
	 * 
	 * @var array
	 */
	protected $_sorts = array();
	
	/**
	 * The css class for the HTML table.
	 * 
	 * @var string
	 */
	protected $_table_class = 'table table-striped';
	
	/**
	 * The total records after processed the
	 * filters.
	 * 
	 * @var int
	 */
	protected $_total_records = 0;
	
	/**
	 * The URI prefix segment for filter request.
	 * Eg: filter_filtername=filter+value
	 * 
	 * @var string
	 */
	protected $_uri_filter_prefix = 'filter_';
	
	/**
	 * The string that used for page URI segment.
	 * 
	 * @var string
	 */
	protected $_uri_page = 'page';
	
	/**
	 * The URI prefix segment for sort request.
	 * Eg: sort_sortname=asc
	 * 
	 * @var string
	 */
	protected $_uri_sort_prefix = 'sort_';
	
	/**
	 * The processed CI_DB_active_record object.
	 * 
	 * @var CI_DB_active_record
	 */
	protected $_query = null;
	
	/**
	 * Overriding the parent constructor.
	 * 
	 * @param array optional $options
	 */
	public function __construct($options = array())
	{
		parent::__construct($options);
		
		if ( !$this->_per_page ) {
			$this->_per_page = config_item('per_page');
		}
		
		if ( !$this->_num_links ) {
			$this->_num_links = config_item('num_links');
		}
		
		$this->_process();
	}
	
	/**
	 * To build the URL based on the existing parameter
	 * specified in URI. It allowed overriding by using
	 * the first parameter.
	 * 
	 * @param array $params
	 * @return string
	 */
	public function build_url($params = array())
	{
		//$base_url = $this->get_base_url();
		$base_url = site_url(current_uri());
		
		$uri_data = array();
		
		// Check filter.
		$filters = $this->get_filter_value();
		if ( iterable($filters) ) {
			$tmp_filters = array();
			foreach ( $filters as $filter_name => $filter_value ) {
				$tmp_filters[$this->_uri_filter_prefix . $filter_name] = $filter_value;
			}
			$uri_data = array_merge($uri_data, $tmp_filters);
		}
		
		// Remove other sorting.
		/*if ( !$this->_allowed_multiple_sort ) {
			$sorts = $this->get_sort_value();
			
			if ( iterable($sorts) ) {
				$sort_uris = array();
				
				foreach ( $sorts as $sort_name => $sort_order ) {
					$sort_uris[] = $this->_uri_sort_prefix . $sort_name;
				}
				
				$base_url = remove_url_query($base_url, $sort_uris);
			}
		}*/
		
		// Check page.
		$uri_data[$this->_uri_page] = $this->get_current_page();
		
		$uri_data = array_merge($uri_data, $params);
		
		return add_url_query($base_url, $uri_data);
	}
	
	/**
	 * Return the flag status of multi sort column
	 * 
	 * @return boolean
	 */
	public function get_allowed_multiple_sort()
	{
		return $this->_allowed_multiple_sort;
	}
	
	/**
	 * Get the base URL to the listing page.
	 * 
	 * @deprecated
	 * @return string
	 */
	public function get_base_url()
	{
		if ( !is_empty($this->_base_url) ) {
			return $this->_base_url;
		} else {
			return current_url();
		}
	}
	
	/**
	 * Return the database field binding for the
	 * column. If the column name was not found,
	 * FALSE will be returned.
	 * 
	 * @param string $column_name
	 * @return string|boolean
	 */
	public function get_column($column_name)
	{
		return array_ensure($this->_columns, $column_name, false);
	}
	
	/**
	 * Return all the table columns and it's database
	 * field's binding.
	 * 
	 * @return array
	 */
	public function get_columns()
	{
		return $this->_columns;
	}
	
	/**
	 * Return a specific column width based on the column ID.
	 * If first parameter not provided, all column widths will
	 * be returned in array format. 
	 * 
	 * If the selected column not found, 1 will be returned as
	 * this is the default width of a column.
	 * 
	 * @param string $column_id
	 * @return int|array
	 */
	public function get_column_weight($column_id = '')
	{
		if ( is_empty($column_id) ) {
			return $this->_column_weights;
		} else {
			return array_ensure($this->_column_weights, $column_id, 1);
		}
	}
	
	/**
	 * Return the current page.
	 * 
	 * @return int
	 */
	public function get_current_page()
	{
		$page = $this->_CI->input->get_post($this->_uri_page);
		
		if ( false !== $page && $page > 1 ) {
			return intval($page);
		} else {
			return 1;
		}
	}
	
	/**
	 * Return the data generated by the
	 * listing library.
	 * 
	 * @return array
	 */
	public function get_data()
	{
		return $this->_data;
	}
	
	/**
	 * Return the filter database binding
	 * based on the filter's name. If the
	 * filter name was not found, FALSE
	 * will be returned.
	 * 
	 * @param string $filter_name
	 * @return string|boolean
	 */
	public function get_filter($filter_name)
	{
		return array_ensure($this->_filters, $filter_name, false);
	}
	
	/**
	 * Return the list of filter applied to the
	 * listing in array format. The array key will
	 * be the filter name while the value will be
	 * the filter value.
	 * 
	 * @return array
	 */
	public function get_filter_value()
	{
		$user_filters = array();
		
		if ( iterable($this->_filters) ) {
			foreach ( $this->_filters as $filter_name => $db_field ) {
				$uri_filter_name = $this->_uri_filter_prefix . $filter_name;
				$filter_value = $this->_CI->input->get_post($uri_filter_name);
				
				if ( false !== $filter_value && !is_empty($filter_value) ) {
					$user_filters[$filter_name] = $filter_value;
				}
			}
		}
		
		return $user_filters;
	}
	
	/**
	 * Return all filters.
	 * 
	 * @return array
	 */
	public function get_filters()
	{
		return $this->_filters;
	}
	
	/**
	 * Return the column's label with it's ID.
	 * If no label found, FALSE will be returned.
	 * 
	 * @param $column_id
	 * @return string|boolean
	 */
	public function get_label($column_id)
	{
		return array_ensure($this->_labels, $column_id, false);
	}
	
	/**
	 * Return the column's labels. The array key will
	 * be the column's ID while the value is the label
	 * string.
	 * 
	 * @return array
	 */
	public function get_labels()
	{
		return $this->_labels;
	}
	
	/**
	 * Return the last query string executed.
	 * 
	 * @return string
	 */
	public function get_last_query()
	{
		return $this->_last_query;
	}
	
	/**
	 * Return the layout view script being used.
	 * The script page is relative to the /views/listings/
	 * 
	 * @return string
	 */
	public function get_layout()
	{
		return $this->_layout;
	}
	
	/**
	 * Return the number of link that will
	 * appear before and after the current
	 * page
	 * 
	 * @return int
	 */
	public function get_num_links()
	{
		return $this->_num_links;
	}
	
	/**
	 * Return the number of records per page
	 * to be shown.
	 * 
	 * @return int
	 */
	public function get_per_page()
	{
		return $this->_per_page;
	}
	
	/**
	 * Return the query object.
	 * 
	 * @return CI_DB_active_record
	 */
	public function get_query()
	{
		return $this->_query;
	}
	
	/**
	 * Get the sort database binding
	 * based on the sort's name. If 
	 * the sort name was not found,
	 * FALSE will be returned.
	 * 
	 * @param string $sort_name
	 * @return string|boolean
	 */
	public function get_sort($sort_name)
	{
		return array_ensure($this->_sorts, $sort_name, false);
	}
	
	/**
	 * Return the sorting URL for the sort name.
	 * 
	 * @param string $sort_name
	 * @return string
	 */
	public function get_sort_link($sort_name)
	{
		$sorts = $this->get_sort_value();
		$sort_order = 'asc';
		
		if ( isset($sorts[$sort_name]) && strtolower($sorts[$sort_name]) == 'asc' ) {
			$sort_order = 'desc';
		}
		
		$uri = $this->build_url(array(
			$this->_uri_sort_prefix . $sort_name => $sort_order,
		));
		
	
		if ( !$this->_allowed_multiple_sort ) {
			// Remove all other sort parameter except the sort name.
			$remove_sort = array_keys($sorts);
			$exclude_key = array_search($sort_name, $remove_sort);
			
			if ( false !== $exclude_key ) {
				unset($remove_sort[$exclude_key]);
				
				$remove_sort = array_values($remove_sort);
			}
			
			// Add prefix to each sorts.
			foreach ( $remove_sort as $index => $name ) {
				$remove_sort[$index] = $this->_uri_sort_prefix . $name;
			}
			
			$uri = remove_url_query($uri, $remove_sort);
		}
		
		return $uri;
	}
	
	/**
	 * Return the list of sort that were
	 * applied by client. The array key
	 * will be the sort name while the value
	 * will be the sort order (asc|desc).
	 * 
	 * If first parameter was provided, the
	 * sort order will be returned.
	 * 
	 * @param string optional $sort_name
	 * @return array|string
	 */
	public function get_sort_value($sort_name = '')
	{
		if ( !is_empty($sort_name) ) {
			if ( $this->has_sort($sort_name) ) {
				$uri_sort_name = $this->_uri_sort_prefix . $sort_name;
				$sort_order = $this->_CI->input->get_post($uri_sort_name);
				
				if ( false !== $sort_order && !is_empty($sort_order) && $sort_order == 'desc' ) {
					return 'desc';
				} else {
					return 'asc';
				}
			} else {
				return '';
			}
		} else {
			$user_sorts = array();
			if ( iterable($this->_sorts) ) {
				foreach ( $this->_sorts as $sort_name => $db_field ) {
					$uri_sort_name = $this->_uri_sort_prefix . $sort_name;
					$sort_order = $this->_CI->input->get_post($uri_sort_name);
					
					if ( false !== $sort_order && !is_empty($sort_order) ) {
						if ( strtolower($sort_order) == 'asc' ) {
							$sort_order = 'asc';
						} else {
							$sort_order = 'desc';
						}
						
						$user_sorts[$sort_name] = $sort_order;
					}
				}
			}
			
			return $user_sorts;
		}
	}
	
	/**
	 * Return all sort list in
	 * this listing.
	 * 
	 * @return array
	 */
	public function get_sorts()
	{
		return $this->_sorts;
	}
	
	/**
	 * Return the CSS class for the HTML table.
	 * 
	 * @return string
	 */
	public function get_table_class()
	{
		return $this->_table_class;
	}
	
	/**
	 * This will return the sum of total column weights
	 * defined including those did not defined and
	 * defaulted to 1.
	 * 
	 * @return int
	 */
	public function get_total_column_weight()
	{
		$total_weight = 0;
		
		if ( iterable($this->_columns) ) {
			foreach ( $this->_columns as $column_id => $column ) {
				$weight = $this->get_column_weight($column_id);
				
				$total_weight += $weight;
			}
		}
		
		return $total_weight;
	}
	
	/**
	 * Return the total records found from the query.
	 * 
	 * @return int
	 */
	public function get_total_records()
	{
		return $this->_total_records;
	}
	
	/**
	 * Return the URI prefix used for the 
	 * filtering parameter.
	 * 
	 * @return string
	 */
	public function get_uri_filter_prefix()
	{
		return $this->_uri_filter_prefix;
	}
	
	/**
	 * Return the URI parameter name used for
	 * determining the current page.
	 * 
	 * @return string
	 */
	public function get_uri_page()
	{
		return $this->_uri_page;
	}
	
	/**
	 * Return the prefix used for sorting
	 * parameter request in the URI.
	 * 
	 * @return string
	 */
	public function get_uri_sort_prefix()
	{
		return $this->_uri_sort_prefix;
	}
	
	/**
	 * Check if the filter name exists.
	 * 
	 * @param string $filter_name
	 * @return boolean
	 */
	public function has_filter($filter_name)
	{
		return isset($this->_filters[$filter_name]);
	}
	
	/**
	 * This method will tells you whether there are more
	 * records to be show on next page.
	 * 
	 * @return boolean
	 */
	public function has_more_records()
	{
		$last_record = ($this->get_current_page() - 1) * $this->get_per_page() + $this->get_per_page();
		
		if ( $this->_total_records > $last_record ) {
			return true;
		} else {
			return false;
		}
	}
	
	/**
	 * Check if the sort name exists.
	 * 
	 * @param string $sort_name
	 * @return boolean
	 */
	public function has_sort($sort_name)
	{
		return isset($this->_sorts[$sort_name]);
	}
	
	/**
	 * Check if the filter name has applied or
	 * submitted by client. If the first parameter is
	 * ommited, it will check if there is any
	 * filter applied.
	 * 
	 * @param string optional $filter_name
	 * @return boolean
	 */
	public function is_filter_applied($filter_name = '')
	{
		if ( !is_empty($filter_name) ) {
			$uri_filter_name = $this->_uri_filter_prefix . $filter_name;
			
			if ( false === ($filter_value = $this->_CI->input->get_post($uri_filter_name)) || is_empty($filter_value) ) {
				return false;
			} else {
				return true;
			}
		} else {
			$data = array_merge($_GET, $_POST);
			
			if ( iterable($data) ) {
				foreach ( $data as $key => $value ) {
					if ( preg_match('/^' . $this->_uri_filter_prefix . '.+/', $key) && !is_empty($value) ) {
						return true;
					}
				}
			}
			
			return false;
		}
	}
	
	/**
	 * Check if the sort name is being selected
	 * by the client. If the first parameter is
	 * ommited, it will check if there is any
	 * sort applied.
	 * 
	 * @param string optional $sort_name
	 * @return boolean
	 */
	public function is_sort_applied($sort_name = '')
	{
		if ( !is_empty($sort_name) ) {
			$uri_sort_name = $this->_uri_sort_prefix . $sort_name;
			
			if ( false === ($filter_value = $this->_CI->input->get_post($uri_sort_name)) || is_empty($filter_value) ) {
				return false;
			} else {
				return true;
			}
		} else {
			$data = array_merge($_GET, $_POST);
			
			if ( iterable($data) ) {
				foreach ( $data as $key => $value ) {
					if ( preg_match('/^' . $this->_uri_sort_prefix . '.+/', $key) ) {
						return true;
					}
				}
			}
			
			return false;
		}
	}
	
	/**
	 * Return TRUE if there are more records to be shows.
	 * 
	 * @return boolean
	 */
	public function more_records()
	{
		$curr_page = $this->get_current_page();
		$per_page = $this->get_per_page();
		$record_index = $curr_page * $per_page;
		
		if ( $record_index < $this->_total_records ) {
			return true;
		} else {
			return false;
		}
	}
	
	public function remove_column($column_name)
	{
		if ( isset($this->_columns[$column_name]) ) {
			unset($this->_columns[$column_name]);
		}
		
		if ( isset($this->_sorts[$column_name]) ) {
			unset($this->_sorts[$column_name]);
		}
		
		if ( isset($this->_labels[$column_name]) ) {
			unset($this->_labels[$column_name]);
		}
	}
	
	/**
	 * To remove a filter from the listing library.
	 *
	 * @param string $filter_name
	 * @return null
	 */
	public function remove_filter($filter_name)
	{
		if ( isset($this->_filters[$filter_name]) ) {
			unset($this->_filters[$filter_name]);
		}
	}
	
	/**
	 * To remove a sort from the listing library.
	 * 
	 * @param string $sort_name
	 * @return null
	 */
	public function remove_sort($sort_name)
	{
		if ( isset($this->_sorts[$sort_name]) ) {
			unset($this->_sorts[$sort_name]);
		}
	}
	
	/**
	 * Render the listing and return the output string.
	 * 
	 * @return string
	 */
	public function render()
	{
		$header = array();
		$data = array();
		
		if ( iterable($this->_columns) ) {
			foreach ( $this->_columns as $column_id => $db_field ) {
				$column_label = $this->get_label($column_id);
				
				if ( false !== $column_label ) {
					$sort_link = '';
					$current_sort = '';
					
					if ( $this->has_sort($column_id) ) {
						$sort_link = $this->get_sort_link($column_id);
						
						$current_sort = $this->get_sort_value($column_id);
					}
					
					$header[] = array(
						'id' => $column_id,
						'label' => $column_label,
						'sort_link' => $sort_link,
						'current_sort' => $current_sort,
					);
				} else {
					$header[] = array(
						'id' => $column_id,
						'label' => '[Not Specified]',
						'sort_link' => '',
						'current_sort' => '',
					);
				}
			}
			
			if ( iterable($this->_data) ) {
				foreach ( $this->_data as $row ) {
					$data_row = array();
					
					foreach ( $this->_columns as $column_id => $db_field ) {
						$value =  array_ensure($row, $db_field, '');
						
						$data_row[] = $value;
					}
					
					$data[] = $data_row;
				}
			}
		}
		
		// Get the listing view script.
		$script_path = $this->_CI->template->get_view_path('listings/' . $this->_layout);
		
		if ( false !== $script_path ) {
			// Load pagination script if has data.
			$pagination = '';
			if ( $this->get_total_records() > 0 ) {
				$pagination = $this->_load_pagination();
			}
			
			$output = $this->_CI->load->view($script_path, array(
				'listing' => $this,
				'headers' => $header,
				'data' => $data,
				'has_data' => ($this->get_total_records() > 0 ? true : false),
				'pagination' => $pagination,
			), true);
			
			return $this->_CI->template->get_base_url($output);
		} else {
			// Form layout not found.
			log_message('error', 'No view found for listing layout.');
			show_error(lang('_error_listing_view_not_found'));
		}
	}
	
	/**
	 * Set whether to allowed multiple sort or not.
	 * 
	 * @param boolean $multisort
	 * @return null
	 */
	public function set_allowed_multiple_sort($multisort)
	{
		$this->_allowed_multiple_sort = ($multisort ? true : false);
	}
	
	/**
	 * Set the base URL of the listing page.
	 * 
	 * @deprecated
	 * @param string $url
	 * @return null
	 */
	public function set_base_url($url)
	{
		if ( is_absolute_url($url) ) {
			$this->_base_url = $url;
		} else {
			$this->_base_url = site_url($url);
		}
	}
	
	/**
	 * To set a column and it's database field name.
	 * The field name must exists in the query result.
	 * The second parameter can be leave blank and use
	 * custom function to format the data outcome.
	 * It can be a string or array as well.
	 * 
	 * If array was passed to the second parameter, it
	 * accept the following options:
	 * field - The database field's name
	 * label - The label of the column
	 * sort - Whether this column is sortable
	 * sort_field - The sorting database field
	 * order - To define the order of the column
	 * 
	 * The order option accept integer value where
	 * it used to place the column accordingly. The
	 * index start with 0. Use -1 to indicate the
	 * last column or 0 as the first column.
	 * 
	 * @param string $column_name
	 * @param string|array $db_field
	 * @return null
	 */
	public function set_column($column_name, $db_field = '')
	{
		if ( iterable($db_field) ) {
			$label = array_ensure($db_field, 'label', '');
			$sort = array_ensure($db_field, 'sort', false);
			$field = array_ensure($db_field, 'field', '');
			$sort_field = array_ensure($db_field, 'sort_field', false);
			$order = array_ensure($db_field, 'order', -1);
			$weight = array_ensure($db_field, 'weight', false);
			
			if ( $order == -1 ) {
				$this->_columns[$column_name] = $field;
			} elseif ( $order == 0 ) {
				$this->_columns = array_merge(array($column_name => $field), $this->_columns);
			} else {
				// at specific index.
				$arry = array_slice($this->_columns, 0, $order, true);
				$arry += array($column_name => $field);
				$arry += array_slice($this->_columns, $order, sizeof($this->_columns) - $order, true);
				$this->_columns = $arry;
			}
			
			if ( $weight > 0 ) {
				$this->set_column_weight($column_name, $weight);
			}
			
			if ( !is_empty($label) ) {
				$this->set_label($column_name, $label);
			}
			
			if ( $sort ) {
				if ( false !== $sort_field ) {
					$this->set_sort($column_name, $sort_field);
				} else {
					$this->set_sort($column_name, $field);
				}
			}
		} else {
			$this->_columns[$column_name] = $db_field;
		}
	}
	
	/**
	 * To set multiple columns into the listing table.
	 * The array key can be the column. The array value
	 * can be the database field or the column key.
	 * It accept label and sorting to be set together in
	 * the array. Eg:
	 * array(
	 *   col_name => array(
	 *     'label' => label,
	 *     'sort' => true,
	 *     'field' => db_field_name,
	 *   ), ...
	 * )
	 * 
	 * @param array $columns
	 * @return null
	 */
	public function set_columns($columns)
	{
		if ( iterable($columns) ) {
			foreach ( $columns as $col_name => $db_field ) {
				if ( is_pure_digits($col_name) ) {
					$this->set_column($db_field);
				} else {
					if ( iterable($db_field) ) {
						// Special set.
						$label = array_ensure($db_field, 'label', '');
						$sort = array_ensure($db_field, 'sort', false);
						$field = array_ensure($db_field, 'field', '');
						$weight = array_ensure($db_field, 'weight', false);
						$sort_field = array_ensure($db_field, 'sort_field', false);
						
						if ( is_empty($field) ) {
							$field = $col_name;
						}
						
						$this->set_column($col_name, $field);
						
						if ( !is_empty($label) ) {
							$this->set_label($col_name, $label);
						}
						
						if ( $weight > 0 ) {
							$this->set_column_weight($col_name, $weight);
						}
						
						if ( $sort ) {
							if ( false !== $sort_field ) {
								$this->set_sort($col_name, $sort_field);
							} else {
								$this->set_sort($col_name, $field);
							}
						}
					} else {
						$this->set_column($col_name, $db_field);
					}
				}
			}
		}
	}
	
	/**
	 * Set the column weight.
	 * 
	 * @param string $column_id
	 * @param int $weight
	 * @return null
	 */
	public function set_column_weight($column_id, $weight)
	{
		$this->_column_weights[$column_id] = $weight;
	}
	
	/**
	 * Set multiple column's weights at one go
	 * 
	 * @param array $column_weights
	 * @return array
	 */
	public function set_column_weights($column_weights)
	{
		if ( iterable($column_weights) ) {
			foreach ( $column_weights as $id => $weight ) {
				$this->set_column_weight($id, $weight);
			}
		}
	}
	
	/**
	 * To set a filter key and it's binding to the
	 * listing.
	 * 
	 * @param string $filter
	 * @param string optional $db_field
	 * @return null
	 */
	public function set_filter($filter, $db_field = '')
	{
		$this->_filters[$filter] = $db_field;
	}
	
	/**
	 * Set multiple filter into the listing
	 * library. The array key can be the filter
	 * name while the value can be the database
	 * field name. If no field name to be bind,
	 * use array value as the filter name.
	 * 
	 * @param array $filters
	 * @return null
	 */
	public function set_filters($filters)
	{
		if ( iterable($filters) ) {
			foreach ( $filters as $key => $db ) {
				if ( preg_match('/^\d+$/', $key) ) {
					$this->set_filter($db, '');
				} else {
					$this->set_filter($key, $db);
				}
			}
		}
	}
	
	/**
	 * To set the label of the column based on the
	 * column's ID.
	 * 
	 * @param string $column_id
	 * @param string $label
	 * @return null
	 */
	public function set_label($column_id, $label)
	{
		$this->_labels[$column_id] = $label;
	}
	
	/**
	 * To set multiple labels at one go.
	 * 
	 * @param array $labels
	 * @return null
	 */
	public function set_labels($labels)
	{
		if ( iterable($labels) ) {
			foreach ( $labels as $column_id => $label ) {
				$this->set_label($column_id, $label);
			}
		}
	}
	
	/**
	 * Set the layout script name. The layout script is
	 * relative to the /views/listings/ folder.
	 * 
	 * @param string $layout
	 * @return null
	 */
	public function set_layout($layout)
	{
		$this->_layout = $layout;
	}
	
	/**
	 * To set the number of links appear before and
	 * after the current page number.
	 * 
	 * @param int $num_links
	 * @return null
	 */
	public function set_num_links($num_links)
	{
		$this->_num_links = intval($num_links);
	}
	
	/**
	 * Set the number of record per page.
	 * 
	 * @param int $per_page
	 * @return null
	 */
	public function set_per_page($per_page)
	{
		$this->_per_page = intval($per_page);
	}
	
	/**
	 * Set a sort key and the database field bind
	 * to it.
	 * 
	 * @param string $sort_name
	 * @param string optional $db_field
	 * @return null
	 */
	public function set_sort($sort_name, $db_field = '')
	{
		$this->_sorts[$sort_name] = $db_field;
	}
	
	/**
	 * Set multiple sorting name and database field
	 * into the listing library.
	 * 
	 * @param array $sorts
	 * @return null
	 */
	public function set_sorts($sorts)
	{
		if ( iterable($sorts) ) {
			foreach ( $sorts as $sort_name => $db_field ) {
				if ( is_pure_digits($sort_name) ) {
					$this->set_sort($db_field, '');
				} else {
					$this->set_sort($sort_name, $db_field);
				}
			}
		}
	}
	
	/**
	 * Set the HTML table class.
	 * 
	 * @param string $class
	 * @return null
	 */
	public function set_table_class($class)
	{
		$this->_table_class = $class;
	}
	
	/**
	 * To load the pagination from the data generated.
	 * This is the default pagination class from CodeIgniter.
	 * Sub class can override this method to generate
	 * custom pagination output.
	 * 
	 * @return string
	 */
	protected function _load_pagination()
	{
		$this->_CI->load->library('pagination');
		$base_url = $this->build_url();
		
		// Remove the page param from the URL.
		$base_url = remove_url_query($base_url, array($this->_uri_page));
		
		if ( !has_query($base_url) ) {
			$base_url .= '?1=1';
		}
		
		$config = array(
			'base_url' => $base_url,
			'total_rows' => $this->get_total_records(),
			'per_page' => $this->_per_page,
			'page_query_string' => true,
			'use_page_numbers' => true,
			'query_string_segment' => $this->_uri_page,
			'num_links' => $this->_num_links,
			// Custom tag.
			'full_tag_open' => '<ul class="pagination">',
			'full_tag_close' => '</ul>',
			'num_tag_open' => '<li>',
			'num_tag_close' => '</li>',
			'cur_tag_open' => '<li class="active"><a>',
			'cur_tag_close' => '<span class="sr-only">(current)</span></a></li>',
			'next_tag_open' => '<li>',
			'next_tag_close' => '</li>',
			'prev_tag_open' => '<li>',
			'prev_tag_close' => '</li>',
			'first_link' => lang('first'),
			'first_tag_open' => '<li>',
			'first_tag_close' => '</li>',
			'last_link' => lang('last'),
			'last_tag_open' => '<li>',
			'last_tag_close' => '</li>',
		);
		
		$this->_CI->pagination->initialize($config);
		
		return $this->_CI->pagination->create_links();
	}
	
	/**
	 * Process the listing query result and it's
	 * filter, sorting and pagination.
	 * 
	 * @return null
	 */
	protected function _process()
	{
		// Apply filters...
		$filters = $this->get_filter_value();
		
		if ( iterable($filters) ) {
			foreach ( $filters as $filter_name => $filter_value ) {
				// Get the database field that binded.
				$db_field = $this->get_filter($filter_name);
				
				if ( false !== $db_field && !is_empty($db_field) ) {
					// Apply directly to the database field.
					$field_segments = preg_split('/ /', $db_field);
					$segment_size = sizeof($field_segments);
					
					if ( $segment_size >= 1 && $segment_size <= 2 ) {
						// Only field name provided, just apply with equal sign.
						$this->_CI->db->where($db_field, $filter_value);
					} else if ( $segment_size >= 3 ) {
						// Token provided.
						$db_field = preg_replace('/\[value\]/', $filter_value, $db_field);
						
						$this->_CI->db->where($db_field);
					}
				} else {
					// No database field binding. Use custom method to do filter.
					$method_name = '_filter_' . $filter_name;
					
					if ( method_exists($this, $method_name) ) {
						call_user_func(array($this, $method_name), $this->_CI->db, $filter_value);
					}
				}
			}
		}
		
		// Apply sorts...
		$sorts = $this->get_sort_value();
		
		if ( iterable($sorts) ) {
			foreach ( $sorts as $sort_name => $sort_order ) {
				// Get the field's name and sort it accordingly.
				$db_field = $this->get_sort($sort_name);
				
				if ( false !== $db_field && !is_empty($db_field) ) {
					$this->_CI->db->order_by($db_field, $sort_order);
				}
				
				// Now see if there is any custom sorting method available.
				$method_name = '_sort_' . $sort_name;
				
				if ( method_exists($this, $method_name) ) {
					call_user_func(array($this, $method_name), $this->_CI->db, $sort_order);
				}
				
				if ( !$this->_allowed_multiple_sort ) {
					// We only allowed the listing to use the first sorting field.
					break;
				}
			}
		}
		
		// Apply row limit.
		$current_page = $this->get_current_page();
		$starting_index = ($current_page - 1) * $this->_per_page;
		
		$this->_CI->db->limit($this->_per_page, $starting_index);
		
		if ( null === $this->_query ) {
			// Generate the query.
			$qry = $this->_CI->db->get();
			
			$this->_last_query = $this->_CI->db->last_query();
			
			// Set the query object.
			$this->_query = $qry;
		} else {
			$qry = $this->_query;
		}
		
		// Get the last query string.
		$qry_string = $this->_CI->db->last_query();
		
		log_message('debug', 'Listing query: ' . $qry_string);
		
		// Manipulate the last query string and generate total result.
		$query_lines = (explode("\n", $qry_string));
		
		if ( iterable($query_lines) ) {
			// Remove all select statement.
			foreach ( $query_lines as $index => $line ) {
				if ( preg_match('/^FROM \(\`[^\`]+\`\)$/i', $line) ) {
					$query_lines = array_slice($query_lines, $index - 1);
					
					break ;
				}
			}
			
			// Change the first line to select count statement.
			$query_lines[0] = 'SELECT COUNT(*) AS `total_records`';
			
			// See if the last line is a limit, if so, remove it.
			$last_index = sizeof($query_lines) - 1;
			if ( preg_match('/limit/i', $query_lines[$last_index]) ) {
				unset($query_lines[$last_index]);
				
				$query_lines = array_values($query_lines);
			}
			
			// Now check if the last line is order field.
			$last_index = $last_index - 1;
			if ( preg_match('/^order by/i', $query_lines[$last_index]) ) {
				unset($query_lines[$last_index]);
				
				$query_lines = array_values($query_lines);
			}
		}
		
		/* 
		 * Check if there is a custom function which will count
		 * the total records in the query. The function must set
		 * $this->_total_records manually.
		 * If the count records is false, the application class
		 * will use back the default algorithm to determine the
		 * total records.
		 */
		$count_records = false;
		
		if ( method_exists($this, '_count_records') ) {
			$count_records = $this->_count_records($query_lines);
		}
		
		if ( $count_records === false ) {
			// Rejoin the query.
			$qry_string = implode("\n", $query_lines);
			
			// Get the total records found.
			$qry_count = $this->_CI->db->query($qry_string);
			
			if ( $qry_count->num_rows() ) {
				$result = $qry_count->result_array();
				$this->_total_records = $result[0]['total_records'];
			}
		}
		
		// Set the _data variable.
		if ( $qry->num_rows() > 0 ) {
			$result = $qry->result_array();
			
			// Run the format function.
			if ( iterable($this->_columns) ) {
				foreach ( $result as $index => $row ) {
					foreach ( $this->_columns as $column_id => $db_field ) {
						$db_value = array_ensure($row, $db_field, '');
						
						$method_name = '_format_' . $column_id;
						
						if ( method_exists($this, $method_name) ) {
							$formatted_value = call_user_func_array(array($this, $method_name), array(
								$index + $starting_index,
								$db_value,
								$row,
							));
							
							// Update the formatted value.
							$result[$index][$db_field] = $formatted_value;
						}
					}
				}
			}
			
			$this->_data = $result;
		} else {
			$this->_data = array();
		}
	}
}